<html>
	<head>
		<link rel="stylesheet" href="style.css">
	</head>
	<body>
		<div id="main">
			<p class="title"> IoT Lab Lecture 3 - 02/04/2024 </p>

			<div class="divider"></div>

           <p>
                In this lecture we will see the next big component of the ROS Graph: services.<br>
                We will see how we can write a script to create a service server and a service client to exchange data in a more structured
                way than topics.<br>
                Additionally, we are dedicating a small part to see how you can implement your custom interfaces and write parameters for
                your ROS node.<br><br>

				Some exercises are given to test your coding skills with the new knowledge acquired in this lecture.<br><br>

                Let's get started!
           </p>


            <p class="section">Writing services</p>
			<p>
				We have seen how to write and use topics by writing a script. This leaves us only with services and actions to tackle.<br><br>

				Let's now try to write a simple service and client in Python.<br>
				We will follow an example just like we did before. But this time from here on this page.

				<p class="code">
					ros2 pkg create --build-type ament_python py_srvcli --dependencies rclpy example_interfaces
				</p>

				This time, we are specifying a dependency that our application needs in order to run the service structure.<br>
				This command is not required assuming you have everything already installed, but it is a good practice to specify what
				your package needs in order to run.<br><br>

				If for some reasons you realize that your package has further dependencies after you created it, you can specify them manually
				by writing in the <span class="snippet">package.xml</span> file, it should be kinda intuitive how to edit it.<br><br>

				Now create a new file in <span class="snippet">/src/py_srvcli/py_srvcli</span> called
				<span class="snippet">service_member_function.py</span>, this will be the file were we will write our
				service server.<br><br>

				The code of the node is the following. It is highly recommended to write it line by line instead of copying it, so you can get a good understanding
				of what we're doing.

                    <pre>
from example_interfaces.srv import AddTwoInts

import rclpy
from rclpy.node import Node


class MinimalService(Node):

    def __init__(self):
        super().__init__('minimal_service')
        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)

    def add_two_ints_callback(self, request, response):
        response.sum = request.a + request.b
        self.get_logger().info('Incoming request\na: %d b: %d' % (request.a, request.b))

        return response


def main():
    rclpy.init()

    minimal_service = MinimalService()

    rclpy.spin(minimal_service)

    rclpy.shutdown()


if __name__ == '__main__':
    main()
                    </pre>

				Let's comment the new things we're seeing in this script.<br><br>

				The imported libraries are the same as before for what regards ROS.<br>
				This time though, we are also importing an example interface called <span class="snippet">AddTwoInts</span> from the
				<span class="snippet">example_interfaces</span> package.<br><br>

				This time, we create a service server using the <span cass="snippet">Node</span> method <span class="snippet">create_service()</span>.<br>
				Here, we specify, once again, the message type for the service, the service name, and the callback function.<br>
				Things are not so different from writing for a topic.<br><br>

				The callback <span class="snippet">add_two_ints_callback()</span> takes in input, by default, the request and the response.<br><br>

				Things may get confusing here, but everything may make more sense if we are able to understand how an <span class="snippet">AddTwoInts</span>
				message is structured. Do you remember how to do it?

				<p class="code">
					ros2 interface show example_interfaces/srv/AddTwoInts
				</p>

				<img class="centered" src="imgs/lecture_3/addtwoints_interface.png">

				This tells us the fields of a request, and those of the response!<br><br>

				Now we can go back to our, code, and it should be clear what the following snippet does:

				<pre>
def add_two_ints_callback(self, request, response):
    response.sum = request.a + request.b
    self.get_logger().info('Incoming request\na: %d b: %d' % (request.a, request.b))

    return response
				</pre>

				The rest of the code is exactly like what we have seen before!<br><br>


				We now need to add an entry point for this service, just like we did before for the two talker and listener nodes.<br>
				You should be able to do it by now.<br><br>

				Let's now write the code for our client of the service.<br>
				Create a file named <span class="snippet">client_member_function.py</span> in the <span class="snippet">src/py_srvcli/py_srvcli</span> folder, and write in it the following code:

				<pre>
import sys

from example_interfaces.srv import AddTwoInts
import rclpy
from rclpy.node import Node


class MinimalClientAsync(Node):

    def __init__(self):
        super().__init__('minimal_client_async')
        self.cli = self.create_client(AddTwoInts, 'add_two_ints')
        while not self.cli.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('service not available, waiting again...')
        self.req = AddTwoInts.Request()

    def send_request(self, a, b):
        self.req.a = a
        self.req.b = b
        self.future = self.cli.call_async(self.req)
        rclpy.spin_until_future_complete(self, self.future)
        return self.future.result()


def main():
    rclpy.init()

    minimal_client = MinimalClientAsync()
    response = minimal_client.send_request(int(sys.argv[1]), int(sys.argv[2]))
    minimal_client.get_logger().info(
        'Result of add_two_ints: for %d + %d = %d' %
        (int(sys.argv[1]), int(sys.argv[2]), response.sum))

    minimal_client.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
				</pre>

				<br>Let's comment the most interesting parts of this code.

				<pre>
while not self.cli.wait_for_service(timeout_sec=1.0):
    self.get_logger().info('service not available, waiting again...')
self.req = AddTwoInts.Request()
				</pre>

				With the first two lines, we are telling our node to wait for the service to be available before continuing with the execution.<br>
				After that, we instantiate our request message by using the constructor <span class="snippet">Request()</span> of our <span class="snippet">AddTwoInts</span> interface.<br><br>

				The other interesting snippet is how the service is called:

				<pre>
def send_request(self, a, b):
    self.req.a = a
    self.req.b = b
    self.future = self.cli.call_async(self.req)
    rclpy.spin_until_future_complete(self, self.future)
    return self.future.result()
				</pre>

				Here, we are configuring our request and then using it in the function <span class="snippet">call_async()</span>.<br>
				This allows the node to call a service without blocking the rest of the execution of the code.
				<strong>Never</strong> use the function <span class="snippet">call()</span>, unless you are ready to mess with Python Threading.<br><br>
				
				We then use <span class="snippet">spin_until_future_complete()</span> to wait for the service to answer and give us a result.
				Which we then obtain using the <span class="snippet">future.result()</span> function.<br><br>

				The rest of the code should be kinda self explanatory and not too much different from what we have already seen.<br>
				Feel free to ask questions if something is still unclear up to this point.<br><br>

				
				<p class="subsection">Linking again and running</p>

				Now that we also wrote our client, we are ready to add the entry point also for it. After that, we are finally ready to test our example.<br>
				Go back to the main folder and build the package again (remember that you may need to check the dependencies with <span class="snippet">rosdep</span> before being able to build).<br><br>

				Now, after sourcing your package, you should be able to run your service with the following commands.<br>
				First, start the service with:

				<p class="code">
					ros2 run py_srvcli service
				</p>

				And then make a request to it with the client node:

				<p class="code">
					ros2 run py_srvcli client 2 3
				</p>

				This should output something like this:

				<img class="centered" src="imgs/lecture_3/service_client.png">

			</p>


			<p class="section">Exercise 3 - <span class="rainbow-text">Rainbow</span> Turtle!</p>

			<p>
				We now know how to write services in ROS.<br>

				Let's go back to the exercise we did before and complicate things a little bit!<br><br>

				You are here asked to change the script in Exercise 2 as follows:<br>
				when the turtle reaches a corner, the color of the line the turtle leaves behind should change!<br><br>

				There is one particular service responsible for the color of the line, try to find it out by tinkering
				with all the commands we have seen so far (looking online for more documentation, if you are having problems, is totally fair)!<br><br>

				Some tips may be needed here, as using topics and services together can create lots of problems without knowing how ROS works under the hood.
				The most important thing you need to know: you should <strong>NEVER call a spin action for a node that is already spinning</strong>, that can create problems in the 
				scheduler of ROS.<br><br>
				If you want to see the result of a service from a node, but that node is already spinning, you may use the function
				<span class="snippet">future.add_done_callback()</span>, which allows you to specify a function which gets executed
				when the service has answered your request. You shouldn't need the function in this exercise, but is good to know its existence for the <i>future</i>.<br><br>

				Good luck!<br><br>

				Your solution should look something like this:

            </p>

            <img class="centered" src="imgs/lecture_3/rainbow_turtle.png">

				
            <input class="spoilerbutton" type="button" value="Show" onclick="this.value=this.value=='Show'?'Hide':'Show';">
            <div class="spoiler">
                <div>
					<p>
                        So, first of all. The service you want to send data to is <span class="snippet">/turtle1/set_pen</span>.<br><br>
						You should know by now how to get more info on services and interfaces (<span class="snippet">ros2 service type [service_name]</span> for the message type, and
						<span class="snippet">ros2 interface show [interface_name]</span> for the interface).<br><br>

						With that being done, let's edit our <span class="snippet">turtle_publisher.py</span> from Exercise 2 to accommodate the new request.<br>
						First of all, we want to include the new interface in our code (we are also importing <span class="snippet">randint</span> in order to pick a random color).

						<p class="code">
							from turtlesim.srv import SetPen<br>
							from random import randint
						</p>

						Then, in our class <span class="snippet">__init__()</span> function we are adding few lines to subscribe to the service and instantiate a variable for the request

						<p class="code">
							self.client = self.create_client(SetPen, '/turtle1/set_pen')<br>
							self.req = SetPen.Request()
						</p>

						What we need to add now, is a request to <span class="snippet">/turtle1/set_pen</span> in our <span class="snippet">timer_callback()</span> function, just like we
						did in the service client example from before.

						<p class="code">
							self.req.r = randint(0, 255)<br>
							self.req.g = randint(0, 255)<br>
							self.req.b = randint(0, 255)<br>
							self.req.width = 10<br>
							self.req.off = 0<br><br>
					
							self.future = self.client.call_async(self.req)<br>
							self.publisher.publish(msg)
						</p>


						That's it!<br>
						As it was suggested, this time we did not use the function <span class="snippet">spin_until_future_complete()</span>, mainly for two reasons: first of all,
						our node is already spinning, and calling the function will mess with the ROS execution of our program, secondly, we don't care about the result of the service,
						we just care about sending a message to it in order to change the color of the turtle's trail.<br><br>

						Great! Now you can build your package as usual and try to run it!<br><br>

						The full code of the solution is uploaded here: <a href="exercise_solutions/exercise_3/rainbow_client.py">rainbow_client.py</a>
                    </p>
                </div>
            </div>


        

			<p class="section">Conclusions and <i>future</i> lectures</p>
			<p>
				This completes everything we needed to see for this lecture.<br>
				We're getting really close to be able to fully control a ROS robot.<br>
				In the next lecture, we will discuss mainly about ROS Interface and how you can build custom ones.<br><br>

				See you soon!

				

			</p>


			<div class="to_be_continued"></div>


        </div>
    </body>
</html>