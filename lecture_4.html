<html>
	<head>
		<link rel="stylesheet" href="style.css">
	</head>
	<body>
		<div id="main">
			<p class="title"> IoT Lab Lecture 4 - 10/04/2023 </p>

			<div class="divider"></div>

           <p>
                In this lecture of ROS we will see how to implement custom interfaces for your topics and services! Additionally, we will also see how you can write
				a launch file so that you don't have to start every time every single ROS node!<br><br>

				Let's get to it!
           </p>


			<p class="section">Creating your own Interfaces</p>

			<p>
				If you paid attention to the code carefully, you may have noticed that the code we wrote for the service in the last lecture is using a message of type
				<span class="snippet">AddTwoInts</span>. In order to be able to comfortably work with ROS, you may be 
				required to be able to implement custom messages to pass to your services and topics. This is what we are going to cover in this part!<br><br>

				We will use the same workspace we used so far to test our new interface, so just go back to your
				<span class="snippet">src</span> folder and type:

				<p class="code">
					ros2 pkg create --build-type ament_cmake tutorial_interfaces
				</p>

				This time, we will have to use, sadly, a CMake package. There is currently no way to generate
				<span class="snippet">.msg</span> and <span class="snippet">.srv</span> files in a pure Python package. <br><br>

				What we will do, in order to not use C++, is to define our interfaces in a separate CMake package,
				and then use them inside another Python package.<br><br>

				Interfaces should be defined in their own directories in the package folder, so, just type:

				<p class="code">
					cd tutorial_interfaces <br><br>
					mkidr msg<br>
					mkdir srv
				</p>

				We can start defining our interfaces by creating files in their own folder.<br><br>
				
				Open the <span class="snippet">msg</span> folder, and create a file named <span class="snippet">Num.msg</span>.<br>
				Just open it, and write the following line:

				<p class="code">
					int64 num
				</p>

				And also another file called <span class="snippet">Sphere.msg</span> with the following content:

				<p class="code">
					geometry_msgs/Point center<br>
					float64 radius
				</p>

				This should give you an idea on how to define custom messages that are composed of other already
				defined messages.<br><br>

				Let's now try to create a srv interface!<br><br>

				Go back, and open the <span class="snippet">srv</span> folder. Inside of it, create a file called
				<span class="snippet">AddThreeInts.srv</span> and write in it the following lines:

				<p class="code">
					int64 a<br>
					int64 b<br>
					int64 c<br>
					---<br>
					int64 sum
				</p>

				Here, we are defining a service message which takes in input three integers (<span class="snippet">a</span>, <span class="snippet">b</span> and <span class="snippet">c</span>)
				and returns a single value <span class="snippet">sum</span>.<br><br><br>


				What we have to do now is just to link these new interfaces so that <span class="snippet">colcon</span>
				is able to find them when we build our package.<br><br>

				In the folder of our interface package, open the file <span class="snippet">CmakeList.txt</span> and
				add the following lines:

				<pre>
find_package(geometry_msgs REQUIRED)
find_package(rosidl_default_generators REQUIRED)

rosidl_generate_interfaces(${PROJECT_NAME}
    "msg/Num.msg"
    "msg/Sphere.msg"
    "srv/AddThreeInts.srv"
    DEPENDENCIES geometry_msgs # Add packages that above messages depend on, in this case geometry_msgs for Sphere.msg
)
				</pre>

				All that is left now is to specify the dependencies our package relies on.<br>
				In order to do that, we will have to edit the file <span class="snippet">package.xml</span>.<br><br>

				Interfaces rely on <span class="snippet">rosidl_default_generators</span> in order to generate
				language-specific code, so we will have to add it to our execution-stage dependencies using the tag
				<span class="snippet">&#60;exec_depend&#62;</span>.<br>
				This package belongs to the dependency group <span class="snippet">rosidl_interface_packages</span>,
				which can be defined using the tag <span class="snippet">&#60;member_of_group&#62;</span>.<br>
				Additionally, we have to define our dependency to <span class="snippet">geometry_msgs</span>.<br><br>

				Add the following lines to <span class="snippet">package.xml</span>, inside the <span class="snippet">&lt;package&gt;</span> tag:

				<p class="code">
					&#60;depend&#62;geometry_msgs&#60;/depend&#62;<br><br>

					&#60;build_depend&#62;rosidl_default_generators&#60;/build_depend&#62;<br>
					&#60;exec_depend&#62;rosidl_default_runtime&#60;/exec_depend&#62;<br>
					&#60;member_of_group&#62;rosidl_interface_packages&#60;/member_of_group&#62;
				</p>
				

				This completes everything you need to do in order to implement your interfaces.<br><br>
				
				Go back to the main folder of your workspace, and try to build everything like we always did.<br>
				If you now source you new package, you should be able to see your interfaces with the command:

				<p class="code">
					ros2 interface show [interface_name]
				</p>

				Great! This completes almost everything we need to know about interfaces!<br><br>

				If you wish to build interfaces and write Python code in the same package, you can build your package
				using the <span class="snippet">--build type</span> set to <span class="snippet"> ament_cmake_python</span>.<br>
				There is currently no plan to discuss these type of packages. For the rest of the course we will mainly
				use different packages like	we just did.<br><br>

				<strong>NOTE</strong>: in order for your custom interfaces to be recognized by your IDE and the autocomplete to work, you will need
				to start the IDE from a terminal which has your workspace sourced.<br>
				If you're using Visual Studio Code, you can simply do that by typing:

				<p class="code">
					code [folder_name]
				</p>

				If you want to test your new interfaces, you can try to edit your service and client script we wrote before
				to take <span class="snippet">AddThreeInts</span> in input. If you did the exercises before, it shouldn't
				be hard at all. Give it a try!<br><br>

			</p>



			<p class="section">Exercise 4 - Spin Turtle!</p>

			<p>
				Let's have more "fun" with the turtle!<br><br>

				Now that we know how to write custom interfaces and use them, it is time to test them.<br><br>

				You are here asked to create a service which, when requested, makes the turtle spin on itself for some time.<br>
				The service should use a custom interface message, which takes in input the direction of the spin, and returns a message of your 
				choice as soon as the spin has started (you can use a simple <span class="snippet">string</span> message as a response).<br><br>

				The turtle should do something like this, when requested by the service:

				<img class="centered" src="imgs/lecture_3/turtle_spin.gif">

			</p>


				<input class="spoilerbutton" type="button" value="Show" onclick="this.value=this.value=='Show'?'Hide':'Show';">
				<div class="spoiler">
					<div>
						<p>
							Solution will be online after the lecture!
						</p>
						<!-- <p>
							Sorry for the delay! The solution is now here!<br><br>

							This exercise shouldn't have been that hard, in terms of programming.<br><br>
							
							Assuming that you know how to write your interface and link it, writing the code to use it shouldn't be that hard.<br>
							All we need to do, is to create our callback function for the service server, which takes in input the message with
							the direction of the rotation.<br><br>
							
							Your callback should look something like this:

							<pre>
def spin_callback(self, msg, response):

    dir = msg.dir
    dir = float(dir)

    move_msg = Twist()
    move_msg.linear = Vector3(x=0.0, y=0.0, z=0.0)
    move_msg.angular = Vector3(x=0.0, y=0.0, z=5.0*dir)

    self.publish_to.publish(move_msg)
    response.res = "Spinning!"

    return response
							</pre>

							The interface message used for the service is the following:

							<pre>
int8 dir
---
string res								
							</pre>

							<br>The full code for the service server can be found here: <a href="./exercise_solutions/exercise_4/turtle_spin_service.py">turtle_spin_service.py</a>.<br>
							Here instead, is the file of the interface: <a href="./exercise_solutions/exercise_4/Spin.srv">Spin.srv</a>
						</p> -->
					</div>
				</div>


			<p>
				<strong>EXTRA</strong>: What if you wanted to change the service so that it sends a response only when the rotation is over? 
				Topics are a continuous stream of data without an end, how would you do that?<br>
				Think about it (this extra has nothing to do with interfaces, it is given only to tinker and practice more with ROS).
			</p>

		
            <p class="section">Setting Parameters for your Nodes</p>


			<p>
				Sometimes you may have the need to expose some properties of your nodes outside the scope of your code, maybe to allow 
				some customization or flexibility of the package you are developing.<br>
				This exactly what paremeters are for.<br>
				Additionally, parameters can be set at launch time by defining a special ROS launch file. We will see how to do that in the next lecture.<br><br>

				Creating and setting parameters is pretty easy and straightforward, let's see how we can do it.<br><br>

				Let's create a package for an example:

				<p class="code">
					ros2 pkg create --build-type ament_python python_parameters --dependencies rclpy
				</p>

				<br>And let's create in the appropriate directory a new file called <span class="snippet">python_parameters_node.py</span>.<br>

				This will be the code for our node:

				<pre>
import rclpy
import rclpy.node

class MinimalParam(rclpy.node.Node):
	def __init__(self):
		super().__init__('minimal_param_node')

		self.declare_parameter('my_parameter', 'world')
		self.timer = self.create_timer(1, self.timer_callback)

	def timer_callback(self):
		my_param = self.get_parameter('my_parameter').get_parameter_value().string_value
		self.get_logger().info('Hello %s!' % my_param)

		my_new_param = rclpy.parameter.Parameter(
			'my_parameter',
			rclpy.Parameter.Type.STRING,
			'world'
		)

		all_new_parameters = [my_new_param]
		self.set_parameters(all_new_parameters)

def main():
	rclpy.init()
	node = MinimalParam()
	rclpy.spin(node)

if __name__ == '__main__':
	main()
				</pre>

				<br>Let's comment this code for a little bit.<br>
				As we have previously seen before, in the <span class="snippet">__init__()</span> function we are defining the node name, and scheduling a periodic action of the method <span class="snippet">timer_callback()</span>.<br>
				Additionally, we are defining a parameter named "my_parameter" with a value of "world" using the function <span class="snippet">declare_parameter()</span>.<br><br>

				In the <span class="snippet">timer_callback()</span> method, we have two important functions that are used to interact with parameters.<br>
				One of them is <span class="snippet">get_parameter().get_parameter_value()</span> which allows us to read parameter values and use them in the code.<br>
				The second important function is <span class="snippet">set_parameters()</span>, which allows us to set parameters given in input to a desired value.<br><br>

				What this code does is, essentially, in case of an external modification of the value, resetting every second the "my_parameter" parameter to the "world" value.<br><br><br>


				You can test its execution, after linking, compiling and running it, by changing the parameter from console using the command:

				<p class="code">
					ros2 param set /minimal_param_node my_parameter earth
				</p>

				<br>And that's it!
			</p>


		   	<p class="section">Creating a Launch File</p>

			<p>
				The launch system in ROS 2 is responsible for helping the user describe the configuration of their system and then execute it as described.<br>
				The configuration of the system includes what programs to run, where to run them, what arguments to pass them, and ROS-specific conventions
				which make it easy to reuse components throughout the system by giving them each a different configuration.<br>
				It is also responsible for monitoring the state of the processes launched, and reporting and/or reacting to changes in the state of those processes.<br><br>

				If you are tired of typing every time <span class="snippet">ros2 run ...</span> for every node you have to start, this is what you've been
				waiting for.<br>
				Here is the code of a simple ROS launch file, which starts two Turtlesim applications together. You can copy this script and save it in a file called <span class="snippet">turtlesim_mimic_launch.py</span>
				
			</p>

			<pre>
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='turtlesim',
            namespace='turtlesim1',
            executable='turtlesim_node',
            name='sim'
        ),
        Node(
            package='turtlesim',
            namespace='turtlesim2',
            executable='turtlesim_node',
            name='sim'
        ),
        Node(
            package='turtlesim',
            executable='mimic',
            name='mimic',
            remappings=[
                ('/input/pose', '/turtlesim1/turtle1/pose'),
                ('/output/cmd_vel', '/turtlesim2/turtle1/cmd_vel'),
            ]
        )
    ])
			</pre>
		<p>
			Understanding what this launch file does should be kind of trivial at this point, but let's comment the code for a little bit.<br><br>

			First of all, we have our import of the Python libraries required for writing a Python launch file. 
			<p class="code">
				from launch import LaunchDescription<br>
				from launch_ros.actions import Node
			</p>
			Note that this time, the <span class="snippet">Node</span> class is not imported from <span class="snippet">rclpy</span> libraries, but from <span class="snippet">launch_ros.actions</span>.<br><br>

			Then, we define our function <span class="snippet">generate_launch_description</span>, which returns a new <span class="snippet">LaunchDescription</span>
			object.<br><br>

			The <span class="snippet">LaunchDescription</span> object takes in input an array of ROS2 <span class="snippet">Node</span>,
			which are those which will be executed when the launch file is run.<br>
			Let's look closer to one of the <span class="snippet">Node</span> entry.

			<pre>
Node(
    package='turtlesim',
    namespace='turtlesim1',
    executable='turtlesim_node',
    name='sim'
),
			</pre>

			Here, we define, the package of the node, the namespace for the node, the executable (which is the node itself), and a name for the node.<br>
			One new thing that we haven't seen before, which will be of great importance for bigger projects, is the namespace.<br>
			This allows you to run multiple nodes of the same application, and divide them in different namespaces.<br><br>

			From the full code of the launch file you may see how two turtlesim nodes are started, and created in two different namespaces.<br>
			This allows you to start multiple instances and/or nodes of the same application, without having conflicting topics.<br><br>

			Note that all the <span class="snippet">Node</span> classes can be configured at any given time and then given in input to the <span class="snippet">LaunchDescription</span>
			object. Which means that you could build your <span class="snippet">Node</span> array dinamically before (i.e., maybe depending on some arguments given in input),
			and then give it to <span class="snippet">LaunchDescription</span>.<br><br>

			The above launch file will launch two different turtlesim applications, which can be controlled separately.<br>
			Using the <span class="snippet">cmd_vel</span> topic, thanks to the namespaces, we can instruct the two turtles separately.<br><br>
			One topic will be:
			<p class="code">
				/turtlesim1/turtle1/cmd_vel
			</p>
			And the other:
			<p class="code">
				/turtlesim2/turtle1/cmd_vel
			</p>

			The final part of the code starts the <span class="snippet">mimic</span> node, and with these two lines:

			<pre>
remappings=[
    ('/input/pose', '/turtlesim1/turtle1/pose'),
    ('/output/cmd_vel', '/turtlesim2/turtle1/cmd_vel'),
]
			</pre>

			remaps some topics of the node to different ones. This code will link the two spawned turtles together, making one turtle "mimic" another.<br><br>

			If you want to try the Launch file we just wrote, you can use the following command:

			<p class="code">
				ros2 launch turtlesim_mimic_launch.py
			</p>
</p>
		
			<p class="subsection">Changing parameters at launch</p>

<p>
			As we anticipated in the previous lecture, launch files can also be used to configure node's parameters at run time. Doing that is very simple.<br>
			The following launch file will modify the parameter of the script we wrote in the previous lecture.

			<pre>
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='python_parameters',
            executable='minimal_param_node',
            name='custom_minimal_param_node',
            output='screen',
            emulate_tty=True,
            parameters=[
                {'my_parameter': 'earth'}
            ]
        )
    ])
			</pre>


			The lines:
			<p class="code">
				output='screen',<br>
				emulate_tty=True,
			</p>
			Are used to redirect the output of the node to the console. The reason why this is needed is because nodes launched from a launch file are not directly attached to the std_output of
			your console. Nothing fancy.<br>
		</p>

		<p>
			That's it. Launch files have various degree of customization, more than we need at this point, and more than we would be able to cover in a single lecture.<br>
			Feel free to take a look at the official documentation <a href="https://docs.ros.org/en/humble/Tutorials/Intermediate/Launch/Launch-Main.html">here</a>, if you wish to customize your launcher file in a particular way.
		</p>



		<p class="section">Conclusions</p>

		<p>
			That's it. This lecture might have been a little bit boring in terms of topics discussed. Implementing your own interfaces and scripting launch files is, however,
			something you will have to face in order to program with ROS.<br>
			If you can't remember something from lectures like these it's ok, the ROS documentation and these lectures are here exactly for that.<br><br>

			In the next lecture we will cover the last part of the ROS paradigm: Actions.<br><br>

			See you soon!

		</p>

			<div class="to_be_continued"></div>


        </div>
    </body>
</html>